<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase 1 Infrastructure Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }

        .test-pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .test-fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .summary {
            background-color: #e7f3ff;
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
            border: 1px solid #bee5eb;
        }

        h1 {
            color: #333;
        }

        h2 {
            color: #666;
        }

        .loading {
            text-align: center;
            padding: 20px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üß™ Phase 1 Infrastructure Test</h1>
        <p>Testing the core infrastructure components of the modernized My Playground application.</p>

        <div id="loading" class="loading">
            <p>‚è≥ Running tests...</p>
        </div>

        <div id="results" style="display: none;">
            <h2>Test Results</h2>
            <div id="test-list"></div>

            <div id="summary" class="summary">
                <h3>Summary</h3>
                <div id="summary-content"></div>
            </div>
        </div>
    </div>

    <script type="module">
        // Simple test runner for browser
        class BrowserTestRunner {
            constructor() {
                this.results = [];
            }

            test(name, testFn) {
                try {
                    testFn();
                    this.results.push({ name, status: 'PASS' });
                } catch (error) {
                    this.results.push({ name, status: 'FAIL', error: error.message });
                }
            }

            displayResults() {
                const loading = document.getElementById('loading');
                const results = document.getElementById('results');
                const testList = document.getElementById('test-list');
                const summaryContent = document.getElementById('summary-content');

                loading.style.display = 'none';
                results.style.display = 'block';

                // Display individual test results
                this.results.forEach(result => {
                    const div = document.createElement('div');
                    div.className = `test-result test-${result.status.toLowerCase()}`;

                    if (result.status === 'PASS') {
                        div.innerHTML = `‚úÖ ${result.name}`;
                    } else {
                        div.innerHTML = `‚ùå ${result.name}<br><small>${result.error}</small>`;
                    }

                    testList.appendChild(div);
                });

                // Display summary
                const passed = this.results.filter(r => r.status === 'PASS').length;
                const failed = this.results.filter(r => r.status === 'FAIL').length;

                summaryContent.innerHTML = `
                    <p><strong>Total:</strong> ${this.results.length}</p>
                    <p><strong>Passed:</strong> ${passed}</p>
                    <p><strong>Failed:</strong> ${failed}</p>
                    ${failed === 0 ?
                        '<p style="color: green;"><strong>üéâ All tests passed! Phase 1 infrastructure is working correctly.</strong></p>' :
                        '<p style="color: red;"><strong>‚ùå Some tests failed. Check implementation.</strong></p>'
                    }
                `;
            }
        }

        // Import and test our modules
        async function runTests() {
            const runner = new BrowserTestRunner();

            try {
                // Import modules
                const { Container } = await import('../src/Core/Container.js');
                const { EventBus } = await import('../src/Core/EventBus.js');
                const { ApplicationError, ValidationError } = await import('../src/Core/Errors/ApplicationErrors.js');
                const { ErrorHandler } = await import('../src/Core/Errors/ErrorHandler.js');

                // Container Tests
                runner.test('Container: Should register and resolve services', () => {
                    const container = new Container();
                    container.register('test', () => 'test-service');

                    const service = container.get('test');
                    if (service !== 'test-service') {
                        throw new Error('Service not resolved correctly');
                    }
                });

                runner.test('Container: Should handle singletons', () => {
                    const container = new Container();
                    let counter = 0;
                    container.singleton('counter', () => ++counter);

                    const first = container.get('counter');
                    const second = container.get('counter');

                    if (first !== second || first !== 1) {
                        throw new Error('Singleton not working correctly');
                    }
                });

                runner.test('Container: Should detect circular dependencies', () => {
                    const container = new Container();
                    container.register('a', (c) => c.get('b'));
                    container.register('b', (c) => c.get('a'));

                    try {
                        container.get('a');
                        throw new Error('Should have thrown circular dependency error');
                    } catch (error) {
                        if (!error.message.includes('Circular dependency')) {
                            throw error;
                        }
                    }
                });

                // EventBus Tests
                runner.test('EventBus: Should subscribe and emit events', () => {
                    const eventBus = new EventBus();
                    let eventReceived = false;

                    eventBus.subscribe('test', () => {
                        eventReceived = true;
                    });

                    eventBus.emitSync('test');

                    if (!eventReceived) {
                        throw new Error('Event not received');
                    }
                });

                runner.test('EventBus: Should handle once subscriptions', () => {
                    const eventBus = new EventBus();
                    let callCount = 0;

                    eventBus.once('test', () => {
                        callCount++;
                    });

                    eventBus.emitSync('test');
                    eventBus.emitSync('test');

                    if (callCount !== 1) {
                        throw new Error('Once subscription called multiple times');
                    }
                });

                // Error Handling Tests
                runner.test('ApplicationError: Should create custom errors', () => {
                    const error = new ApplicationError('Test error', {
                        code: 'TEST_ERROR',
                        context: { test: true }
                    });

                    if (error.message !== 'Test error' || error.code !== 'TEST_ERROR') {
                        throw new Error('ApplicationError not created correctly');
                    }
                });

                runner.test('ValidationError: Should extend ApplicationError', () => {
                    const error = new ValidationError('Validation failed');

                    if (!(error instanceof ApplicationError) || error.code !== 'VALIDATION_ERROR') {
                        throw new Error('ValidationError not extending correctly');
                    }
                });

                runner.test('ErrorHandler: Should handle errors gracefully', () => {
                    // Create a mock logger to avoid console output during tests
                    const mockLogger = {
                        warn: () => { }, // Silent mock
                        error: () => { } // Silent mock
                    };
                    const errorHandler = new ErrorHandler(mockLogger);
                    const testError = new Error('Test error');

                    // Should not throw
                    errorHandler.handle(testError);
                });

                // Integration Tests
                runner.test('Integration: Container and EventBus work together', () => {
                    const container = new Container();
                    const eventBus = new EventBus();

                    container.singleton('eventBus', () => eventBus);

                    const retrievedEventBus = container.get('eventBus');

                    if (retrievedEventBus !== eventBus) {
                        throw new Error('Container and EventBus integration failed');
                    }
                });

            } catch (importError) {
                runner.test('Module Import', () => {
                    throw new Error(`Failed to import modules: ${importError.message}`);
                });
            }

            runner.displayResults();
        }

        // Run tests when page loads
        runTests();
    </script>
</body>

</html>