<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shows & Songs</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="layout">
    <aside class="sidebar" aria-hidden="true"></aside>
    <div class="container main">
      <h1>Shows & Songs</h1>
      <section>
        <h2>Anime / Shows</h2>
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:0.6rem">
          <label for="mal-username" class="small">MAL username:</label>
          <input id="mal-username" type="text" placeholder="woquendo"
            style="padding:6px;border-radius:6px;border:1px solid #ddd" />
          <button id="import-btn" class="btn">Import anime list</button>
          <button id="download-btn" class="btn">Download JSON</button>
          <button id="reload-packaged" class="btn">Reload packaged JSON</button>
          <button id="clear-local" class="btn small">Clear Local</button>
        </div>
        <pre id="import-log" class="small"
          style="max-height:200px;overflow:auto;white-space:pre-wrap;background:#fff;padding:8px;border:1px solid #eee;border-radius:6px;display:none"></pre>
        <div id="shows" class="show-list">
          <p class="small">Loading anime list and shows…</p>
        </div>
      </section>

      <section>
        <h2>Songs</h2>
        <div id="songs" class="song-list">
          <p class="small">Loading songs…</p>
        </div>
      </section>

      <div class="footer">Tip: run a local server to test (see README in this folder). Works directly on GitHub Pages.
      </div>
    </div>
  </div>

  <script>
    // Fallback data in case fetch fails (e.g., opened via file:// without a server)
    const fallbackData = {
      shows: [
        { title: "Summer Festival", date: "2025-07-15", location: "NYC", description: "Outdoor performance at Central Park." },
        { title: "Autumn Tour", date: "2025-10-01", location: "Chicago", description: "Acoustic set at the Lakeside Theater." }
      ],
      songs: [
        { title: "Morning Light", artist: "The Skylines", youtube: "https://www.youtube.com/watch?v=dQw4w9WgXcQ" },
        { title: "Midnight Run", artist: "The Skylines", youtube: "https://www.youtube.com/watch?v=kXYiU_JCYtU" }
      ]
    };

    // Utility: extract YouTube video ID from common URL forms
    function extractYouTubeId(url) {
      if (!url) return null;
      // patterns: v=ID, youtu.be/ID, /embed/ID
      const vMatch = url.match(/[?&]v=([\w-]{11})/);
      if (vMatch && vMatch[1]) return vMatch[1];
      const shortMatch = url.match(/youtu\.be\/([\w-]{11})/);
      if (shortMatch && shortMatch[1]) return shortMatch[1];
      const embedMatch = url.match(/embed\/([\w-]{11})/);
      if (embedMatch && embedMatch[1]) return embedMatch[1];
      // last resort: try to find 11-char id in the url
      const general = url.match(/([\w-]{11})/);
      return general ? general[1] : null;
    }

    function render(data) {
      const showsEl = document.getElementById('shows');
      const songsEl = document.getElementById('songs');

      // Shows / Anime
      showsEl.innerHTML = '';
      if (!data.shows || data.shows.length === 0) {
        showsEl.innerHTML = '<div class="small">No shows or anime found.</div>';
      } else {
        // If items have a `status` field treat them as anime entries and group
        const isAnime = data.shows.some(s => s.status);
        if (isAnime) {
          const order = ['watching', 'plan_to_watch', 'completed', 'on_hold', 'dropped'];
          const groups = {};
          data.shows.forEach(s => {
            const st = (s.status || 'unknown').toString().toLowerCase();
            if (!groups[st]) groups[st] = [];
            groups[st].push(s);
          });

          order.forEach(st => {
            if (groups[st] && groups[st].length) {
              const header = document.createElement('h3');
              header.textContent = `${st.replace(/_/g, ' ')} (${groups[st].length})`;
              showsEl.appendChild(header);
              groups[st].forEach(item => {
                const div = document.createElement('div');
                div.className = 'show-item';
                const title = item.title || item.name || (item.node && item.node.title) || 'Untitled';
                const url = item.url || (item.node && item.node.url) || (item.anime && item.anime.url) || '';
                const meta = url ? `<a href="${url}" target="_blank" rel="noopener noreferrer">${title}</a>` : title;
                div.innerHTML = `<strong>${meta}</strong><div class="small">${item.episodes ? item.episodes + ' eps' : ''} ${item.score ? '• score: ' + item.score : ''}</div>`;
                showsEl.appendChild(div);
              });
            }
          });
        } else {
          data.shows.forEach(s => {
            const li = document.createElement('div');
            li.className = 'show-item';
            li.innerHTML = `<strong>${s.title}</strong> — <span class="small">${s.date ? new Date(s.date).toLocaleDateString() : ''} ${s.location ? '(' + s.location + ')' : ''}</span><div class="small">${s.description || ''}</div>`;
            showsEl.appendChild(li);
          });
        }
      }

      // Songs: compact searchable & paginated list with a single player
      songsEl.innerHTML = '';
      const songs = (data.songs || []).slice();
      if (!songs.length) {
        songsEl.innerHTML = '<p class="small">No songs available.</p>';
      } else {
        const playerContainer = document.createElement('div');
        playerContainer.id = 'song-player';
        playerContainer.className = 'song-item';
        playerContainer.innerHTML = '<div class="small">Select a song to load the player.</div>';
        songsEl.appendChild(playerContainer);

        const controls = document.createElement('div');
        controls.className = 'song-list-controls';
        controls.innerHTML = `<input id="song-search" placeholder="Search songs or artists" style="flex:1;padding:6px;border-radius:6px;border:1px solid #ddd" /> <select id="page-size" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid #ddd"><option value="5">5/page</option><option value="8">8/page</option><option value="12">12/page</option></select>`;
        songsEl.appendChild(controls);

        const listWrap = document.createElement('div');
        listWrap.id = 'song-list-wrap';
        listWrap.style.maxHeight = '420px';
        listWrap.style.overflow = 'auto';
        listWrap.style.marginTop = '0.6rem';

        const list = document.createElement('div');
        list.id = 'song-list-items';
        list.className = 'song-cards';
        listWrap.appendChild(list);
        songsEl.appendChild(listWrap);

        const pager = document.createElement('div');
        pager.className = 'pager small';
        pager.style.marginTop = '0.6rem';
        pager.innerHTML = '<button id="prev-page" class="btn small">Prev</button> <span id="page-info" style="margin:0 8px"></span> <button id="next-page" class="btn small">Next</button>';
        songsEl.appendChild(pager);

        // pagination & filter state
        let currentPage = 1;
        let pageSize = parseInt(document.getElementById('page-size').value, 10) || 5;

        const searchInput = document.getElementById('song-search');

        function renderSongPage() {
          const q = (searchInput.value || '').trim().toLowerCase();
          const filtered = songs.filter(s => {
            const t = (s.title || '').toString().toLowerCase();
            const a = (s.artist || '').toString().toLowerCase();
            return !q || t.includes(q) || a.includes(q);
          });
          const total = filtered.length;
          const totalPages = Math.max(1, Math.ceil(total / pageSize));
          if (currentPage > totalPages) currentPage = totalPages;
          const start = (currentPage - 1) * pageSize;
          const pageItems = filtered.slice(start, start + pageSize);

          list.innerHTML = '';
          pageItems.forEach((song, idx) => {
            const realIdx = start + idx;
            const card = document.createElement('div');
            card.className = 'song-card';
            const title = song.title || 'Untitled';
            const artist = song.artist ? `<div class="small artist">${song.artist}</div>` : '';
            card.innerHTML = `<div class="song-card-inner"><div><strong>${title}</strong>${artist}</div><div><button class="btn play-btn" data-idx="${realIdx}">Play</button></div></div>`;
            list.appendChild(card);

            card.querySelector('.play-btn').addEventListener('click', () => {
              // highlight
              Array.from(list.querySelectorAll('.song-card')).forEach(c => c.classList.remove('active'));
              card.classList.add('active');
              // load into player
              const videoId = extractYouTubeId(song.youtube || '');
              playerContainer.innerHTML = '';
              if (videoId) {
                const iframe = document.createElement('iframe');
                const autoplayParams = song.autoplay ? '?rel=0&autoplay=1&mute=1' : '?rel=0';
                iframe.src = `https://www.youtube.com/embed/${videoId}${autoplayParams}`;
                iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; autoplay';
                iframe.setAttribute('allowfullscreen', '');
                playerContainer.appendChild(iframe);
              } else if (song.youtube) {
                const a = document.createElement('a');
                a.href = song.youtube;
                a.target = '_blank';
                a.rel = 'noopener noreferrer';
                a.textContent = 'Open on YouTube';
                playerContainer.appendChild(a);
              }
            });
          });

          document.getElementById('page-info').textContent = `${currentPage}/${totalPages} — ${total} songs`;
        }

        document.getElementById('prev-page').addEventListener('click', () => { if (currentPage > 1) { currentPage -= 1; renderSongPage(); } });
        document.getElementById('next-page').addEventListener('click', () => { currentPage += 1; renderSongPage(); });
        document.getElementById('page-size').addEventListener('change', (e) => { pageSize = parseInt(e.target.value, 10); currentPage = 1; renderSongPage(); });
        searchInput.addEventListener('input', () => { currentPage = 1; renderSongPage(); });

        // initial render and auto-select first autoplay if any
        renderSongPage();
        const firstAutoplay = songs.findIndex(s => s.autoplay);
        if (firstAutoplay >= 0) {
          // compute if autoplay item is on current page and trigger play
          const pageOf = Math.floor(firstAutoplay / pageSize) + 1;
          currentPage = pageOf;
          renderSongPage();
          const autoplayBtn = list.querySelector(`button[data-idx="${firstAutoplay}"]`);
          if (autoplayBtn) autoplayBtn.click();
        }
      }
    }

    // Try to fetch JSON; if it fails, use fallbackData
    // Data lifecycle: prefer localStorage -> data/shows_songs.json -> fallback
    const STORAGE_KEY = 'shows_songs_data_v1';

    function saveLocalData(obj) {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
      } catch (e) { console.warn('Could not save to localStorage', e); }
    }

    function loadLocalData() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? JSON.parse(raw) : null;
      } catch (e) { console.warn('Could not read localStorage', e); return null; }
    }

    function downloadJSON(obj, filename = 'shows_songs.json') {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function fetchLocalOrRemote() {
      const local = loadLocalData();
      if (local) {
        render(local);
        return local;
      }
      try {
        const r = await fetch('data/shows_songs.json');
        if (!r.ok) throw new Error('Network response not ok');
        const json = await r.json();
        render(json);
        return json;
      } catch (err) {
        console.warn('Could not fetch data/shows_songs.json — using fallback data.', err);
        render(fallbackData);
        return fallbackData;
      }
    }

    // Functions to import from Jikan (MyAnimeList public data via Jikan API)
    const JIKAN_BASE = 'https://api.jikan.moe/v4';

    async function fetchWithPagination(urlBase, log) {
      // Fetch pages until no next page. Append logs if provided.
      let page = 1;
      let all = [];
      while (true) {
        const url = urlBase + (urlBase.includes('?') ? '&' : '?') + 'page=' + page;
        try {
          log && log.push(`GET ${url}`);
          const res = await fetch(url);
          log && log.push(`  -> ${res.status} ${res.statusText}`);
          if (!res.ok) {
            // If 404 on first page, bail out early
            if (page === 1 && res.status === 404) return { items: [], stoppedBy: 404 };
            break;
          }
          const json = await res.json();
          const data = json.data || [];
          all = all.concat(data);
          // Jikan v4 pagination object
          const pagination = json.pagination || {};
          const hasNext = !!pagination.has_next_page;
          if (!hasNext) break;
          page += 1;
          // safety: avoid infinite loops
          if (page > 50) break;
        } catch (e) {
          log && log.push(`  ! fetch error: ${e.message}`);
          break;
        }
      }
      return { items: all };
    }

    async function fetchAnimelistAll(username) {
      const logEl = document.getElementById('import-log');
      const logs = [];
      logEl.style.display = 'block';
      logEl.textContent = 'Starting import for ' + username + "\n";

      // Try a comprehensive animelist endpoint first
      const tryAllUrlBase = `${JIKAN_BASE}/users/${encodeURIComponent(username)}/animelist?limit=100`;
      logs.push('Attempting comprehensive animelist endpoint...');
      const resultAll = await fetchWithPagination(tryAllUrlBase, logs);
      logs.push(`Comprehensive result: ${resultAll.items.length} items` + (resultAll.stoppedBy ? ` (stoppedBy=${resultAll.stoppedBy})` : ''));

      // If we got items, return them
      if (resultAll.items && resultAll.items.length) {
        logEl.textContent += logs.join('\n') + '\n';
        return resultAll.items;
      }

      // Otherwise, fall back to per-status endpoints
      logs.push('Falling back to per-status endpoints...');
      const statusCandidates = ['watching', 'plan_to_watch', 'completed', 'on_hold', 'dropped'];
      let combined = [];
      for (const st of statusCandidates) {
        const urlBase = `${JIKAN_BASE}/users/${encodeURIComponent(username)}/animelist/${encodeURIComponent(st)}?limit=100`;
        const res = await fetchWithPagination(urlBase, logs);
        logs.push(`Status ${st}: ${res.items.length} items`);
        // tag status where missing
        combined = combined.concat((res.items || []).map(it => (it.status ? it : Object.assign({}, it, { status: st }))));
      }

      logEl.textContent += logs.join('\n') + '\n';
      return combined;
    }

    function normalizeEntry(entry) {
      // entry shape varies; try to read common fields
      const node = entry.anime || entry.node || entry.entry || entry;
      const title = node.title || node.name || node.title_english || node.name_en || (node.mal_id && ("#" + node.mal_id)) || 'Untitled';
      const url = node.url || node.mal_url || '';
      const episodes = node.episodes || node.episodes_aired || node.episode_count || null;
      // entry may carry list_status/status fields
      const status = (entry.status || (entry.list_status && entry.list_status.status) || (entry.animelist_status && entry.animelist_status.status) || '').toString().toLowerCase();
      const score = (entry.score || (entry.list_status && entry.list_status.score) || null);
      return { title, url, episodes, score, status };
    }

    async function importAnimeList(username) {
      const raw = await fetchAnimelistAll(username);
      return raw.map(normalizeEntry);
    }

    // Wire UI
    document.getElementById('import-btn').addEventListener('click', async () => {
      const usernameInput = document.getElementById('mal-username');
      const username = (usernameInput.value || '').trim() || (window.__initialData && window.__initialData.anime_username) || '';
      if (!username) { alert('Please enter a MyAnimeList username.'); return; }
      document.getElementById('import-btn').textContent = 'Importing...';
      try {
        const animeShows = await importAnimeList(username);
        // Build new data object preserving songs
        const base = window.__initialData || fallbackData;
        const newData = Object.assign({}, base, { anime_username: username, shows: animeShows });
        // Persist locally and render
        saveLocalData(newData);
        window.__initialData = newData;
        render(newData);
        alert('Imported ' + animeShows.length + ' entries from MyAnimeList for ' + username + '. Use Download JSON to save a file.');
      } catch (e) {
        console.error(e);
        alert('Import failed: ' + e.message);
      } finally {
        document.getElementById('import-btn').textContent = 'Import anime list';
      }
    });

    document.getElementById('download-btn').addEventListener('click', () => {
      const data = window.__initialData || loadLocalData() || fallbackData;
      downloadJSON(data);
    });

    document.getElementById('reload-packaged').addEventListener('click', async () => {
      try {
        document.getElementById('reload-packaged').textContent = 'Reloading...';
        const r = await fetch('data/shows_songs.json?t=' + Date.now());
        if (!r.ok) throw new Error('Network response not ok: ' + r.status);
        const json = await r.json();
        // overwrite local data so changes persist and render
        saveLocalData(json);
        window.__initialData = json;
        render(json);
        alert('Reloaded packaged JSON and updated local data.');
      } catch (e) {
        alert('Could not reload packaged JSON: ' + e.message);
      } finally {
        document.getElementById('reload-packaged').textContent = 'Reload packaged JSON';
      }
    });

    document.getElementById('clear-local').addEventListener('click', () => {
      localStorage.removeItem(STORAGE_KEY);
      alert('Local data cleared. Reloading from packaged JSON.');
      fetchLocalOrRemote();
    });

    // initial load
    fetchLocalOrRemote().then(d => { window.__initialData = d; const usernameEl = document.getElementById('mal-username'); if (d && d.anime_username) usernameEl.value = d.anime_username; });
  </script>
</body>

</html>